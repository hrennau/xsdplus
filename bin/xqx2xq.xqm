(:
 : -------------------------------------------------------------------------
 :
 : xqx2xq.xqm - Document me!
 :
 : -------------------------------------------------------------------------
 :)
 
module namespace f="http://www.xsdplus.org/ns/xquery-functions";
import module namespace tt="http://www.ttools.org/xquery-functions" at 
    "tt/_request.xqm",
    "tt/_reportAssistent.xqm",
    "tt/_errorAssistent.xqm",
    "tt/_log.xqm",
    "tt/_nameFilter.xqm",
    "tt/_pcollection.xqm";    
    
import module namespace app="http://www.xsdplus.org/ns/xquery-functions" at 
    "constants.xqm",
    "schemaLoader.xqm",
    "seatFunctions.xqm";
    
declare namespace z="http://www.xsdplus.org/ns/structure";
declare namespace zprev="http://www.xsdr.org/ns/structure";

(:~
 : Transforms the XML representation of an XQuery (xqx document)
 : into XQuery code.
 :
 : @param xqx XML representation of an XQuery query
 : @return XQuery code
 :) 
declare function f:xqx2xq($xqx as element(z:xqx))
        as item()* {
    let $codeWrapped :=

    <_>{
        text {string-join((
        "(:", 
        " ==============================================================",
        "   XQuery code generated by xsdplus.",
        "   ", concat("   Generation time: ", current-dateTime()),
        "",
        "   Do not edit this document.",
        "",
        "   Copyright xsdplus 2018",
        " ==============================================================",
        ":)",
        "",
        ""        
        ), '&#xA;')},
        $xqx/* ! f:xqx2xqRC(., 0)        
    }</_>
    return
        let $nodes := $codeWrapped/node()
        return (
             $nodes[1],
             tail($nodes)
        )
};

(:~
 : Recursive helper function of `xqx2xq`.
 :
 : @param n the node to be processed
 : @return the XQuery code represented by this node
 :) 
declare function f:xqx2xqRC($n as node(), $level as xs:integer)
        as item()* {
    typeswitch($n)        
    case document-node() return 
        document {$n/node() ! f:xqx2xqRC(., $level)}

    case element(z:namespaces) return (
        $n/z:namespace !
            text {concat("declare namespace ", @prefix, "='", @uri, "';", "&#xA;")},
        text {'&#xA;'}
    )
    
    case element(z:parameters) return
        for $param in $n/z:parameter 
        return
            concat("declare variable $", replace($param/@name, '.*\s+', ''), " as ", replace($param/@type, '\s.*', ''), ' external;')
    
    case element(z:function) return f:xqx2xqRC_function($n)
    
    case element(z:functions) return
        if ($n/@parsed eq 'false') then $n/text()
        else $n/* ! f:xqx2xqRC(., $level)
    
    case element(z:sequence) return
        let $indent := f:xq_indent($level)
        let $text :=  (
            text {concat($indent, '(', '&#xA;')},
            f:xqx2xqRC_children($n/*, $level),
            text {concat('&#xA;', $indent, ')')}
        )
        return
            $text

    case element(z:choice) return
        let $indent := f:xq_indent($level)
        let $text :=  (
            let $branches := $n/*
            let $countBranches := count($branches)            
            for $branch at $bnr in $branches
            let $prefix := if ($bnr eq 1) then () else 'else '
            let $line := concat($indent, $prefix, 'if (', $branch/@expr,  ') then')
            return (
                text {$line || '&#xA;'},
                f:xqx2xqRC_children($branch/*, $level + 1),
                text {'&#xA;'}
            ),
            text {concat($indent, 'else ()')}
        )
        return
            $text

    case element(z:flwor) return (
        $n/* ! f:xqx2xqRC(., $level)        
    )
    
    case element(z:let) return
        let $indent := f:xq_indent($level)
        let $withReturn :=
            $n/following-sibling::*[1][self::z:let, self::z:for, self::z:group-by] or
            $n/following-sibling::*[1]/self::z:return/*[1][self::z:let, self::z:for, self::z:group-by]
        let $withReturn := ()            
        let $textString :=
            concat($indent, 'let $', $n/@name, ' := ', $n/@expr, ' return'[$withReturn])
        return
            text {$textString || '&#xA;'}

    case element(z:for) return
        let $indent := f:xq_indent($level)
        let $withReturn :=
            $n/following-sibling::*[1][self::z:let, self::for, self::group-by] or
            $n/following-sibling::*[1]/self::return/*[1][self::let, self::for, self::group-by]
        let $withReturn := ()            
        let $textString :=
            concat($indent, 'for $', $n/@name, ' in ', $n/@expr, ' return'[$withReturn])
        return
            text {$textString || '&#xA;'}

    case element(z:return) return    
        let $indent := f:xq_indent($level)
        return
            if ($n/@expr) then
                text {concat($indent, 'return ', $n/@expr)}
            else
                let $nextLevel :=
                    if ($n/../parent::z:xqx) then $level else $level + 1 
                return (
                    text {concat($indent, 'return', '&#xA;')},
                    f:xqx2xqRC_children($n/*, $nextLevel)
                )                

    case element(z:if) return
        let $indent := f:xq_indent($level)
        let $ifCondThen := concat($indent, 'if (', $n/@expr, ') then ')
        return
            if (not($n/z:then/*)) then
                if (not($n/z:else/*)) then
                    text {concat($ifCondThen, $n/z:then/@expr, ' else ', $n/z:else/@expr)}
                else (
                    text {concat($ifCondThen, $n/z:then/@expr, ' else', '&#xA;')},
                    f:xqx2xqRC_children($n/z:else/*, $level)
                )

            else (
                text {$ifCondThen || '&#xA;'},
                f:xqx2xqRC_children($n/z:then/*, $level + 1),
                if (not($n/z:else/*)) then 
                    text {concat($indent, 'else ', $n/z:else/@expr)}   
                else ( 
                    text {concat($indent, 'else', '&#xA;')},
                    f:xqx2xqRC_children($n/z:else/*, $level + 1)
                )
            )                    
            
    case element(z:switch) return
        let $indentUnit := f:xq_indent(1)
        let $indent := f:xq_indent($level)
        let $lines := (
            concat('switch(', $n/@expr, ')'),
            for $case in $n/z:case return
                concat($indentUnit, 'case ', $case/@match, ' return ', $case/@expr),
            $n/z:default/concat($indentUnit, 'default return ', @expr)
        )
        return
            string-join($lines ! concat($indent, .), '&#xA;')
            
    case element(z:value) return
        let $indent := f:xq_indent($level)
        return
            concat($indent, $n/@expr)

    case element(z:attribute) return
        let $indent := f:xq_indent($level)    
        let $expr := $n/@expr
        let $attributeName := concat($indent, 'attribute ', $n/@name, ' {')
        return
            if ($expr) then text {concat($attributeName, $expr, '}')}
            else (
                text {concat($attributeName, '&#xA;')},
                f:xqx2xqRC_children($n/*, $level + 1),
                text {concat($indent, '}')}                
            )
        
    case element() return
        let $indent := f:xq_indent($level)    
        let $expr := $n/@expr
        return (
            text {$indent},
            element {node-name($n)} {
                if ($expr) then text {concat('{', $expr, '}')}
                else (
                    text {'{&#xA;'},
                    f:xqx2xqRC_children($n/*, $level + 1),
                    text {'&#xA;' || $indent || '}'}
                ) 
            }
        )            
    default return $n
};        

declare function f:xqx2xqRC_children($children as element()*, $level as xs:integer) {
    let $countChildren := count($children)
    for $child at $pos in $children 
    return (
        f:xqx2xqRC($child, $level),
        text {',&#xA;'}[$pos lt $countChildren]
    )                
};

(:~
 : Helper function of `xqx2xqRC`, processing a z:function element.
 :
 : @param f xqx element representing a parsed function
 : @return the XQuery code represented by element
 :) 
declare function f:xqx2xqRC_function($f as element(z:function))
        as text() {
    let $params := string-join($f/z:params/z:param ! concat('$', @name, @as/concat(' as ', .)), ', ')   
    let $as := $f/@as
    let $text :=    
        string-join((
            concat('declare function ', $f/@name, '(', $params, ')'),
            concat('        as ', $as, ' {'),
            $f/(* except z:params) ! f:xqx2xqRC(., 1),
            '};'
        ), '&#xA;')
    return
        text {$text || '&#xA;&#xA;'}
};

